package rogel.io.fopl;

import java.util.HashMap;

/**
 * A Symbol is an object that represents. Everything expressed in FOPL is done in terms of
 * Symbols. In this implementation, Symbols follow the Herbrand interpretation and are merely 
 * objects that represent String-based names. There is only <b>one</b> Symbol for any given name.
 * <p>
 * The set of all Symbols that are declared during the execution of any FOPL program constitute
 * that program's domain of discourse. 
 * 
 * @author recardona
 * @see <a href="https://en.wikipedia.org/wiki/Herbrand_interpretation">https://en.wikipedia.org/wiki/Herbrand_interpretation</a>
 */
public final class Symbol {

    /**
     * The domain of discourse is the set of entities over which variables of interest in some 
     * formal language may range. For Symbols, this domain captures every Symbol that has been 
     * used during program execution.
     */
    private static HashMap<String, Symbol> symbolDomainOfDiscourse = new HashMap<String, Symbol>();

    /** 
     * The number to use as a suffix for Symbols generated by the method 
     * {@code Symbol.generateSymbol()}. 
     */
    private static int generatedSymbolSuffix = 0;
    
    /** The String name this Symbol represents. */
    private String name;
    
    /**
     * Returns a Symbol with the given name. If no such Symbol exists, this method creates a new 
     * one and adds it to the domain of discourse for future retrieval.
     * 
     * @param name The name of the Symbol that is sought.
     * @return a Symbol with the given name.
     * @throws IllegalArgumentException if the Symbol name is null or empty.
     */
    public static Symbol get(String name) throws IllegalArgumentException {
        
        if((name == null) || (name.equals(""))) {
            throw new IllegalArgumentException("Attempted to get a Symbol without a name.");
        }

        if(Symbol.symbolDomainOfDiscourse.containsKey(name)) {
            return symbolDomainOfDiscourse.get(name);
        }
        
        Symbol newSymbol = new Symbol(name);
        Symbol.symbolDomainOfDiscourse.put(name, newSymbol);
        return newSymbol;
    }
    
    /**
     * Generates a new Symbol within the domain of discourse. The new Symbol is guaranteed to be 
     * unique, and will be of the form {@code G{number}}, where {@code {number}} is an integer.
     * 
     * @return the newly generated Symbol.
     */
    public static Symbol generateSymbol() {
        
        // Attempt to create an unused Symbol name.
        String generatedSymbolName = "G" + Symbol.generatedSymbolSuffix;
        
        // If that Symbol already exists, increment the counter and try again.
        while(Symbol.symbolDomainOfDiscourse.containsKey(generatedSymbolName)) {
            Symbol.generatedSymbolSuffix++;
            generatedSymbolName = "G" + Symbol.generatedSymbolSuffix;
        }
        
        // Return the new Symbol.
        return Symbol.get(generatedSymbolName);
    }
    
    /**
     * Generates a new Symbol within the domain of discourse. The new Symbol is guaranteed to be
     * unique, and will be of the form {@code {prefix}{number}}, where {@code {prefix}} is the 
     * parameter String, and {@code {number}} is an integer.
     * 
     * @param prefix The prefix of the Symbol to generate.
     * @return the newly generated Symbol.
     */
    public static Symbol generateSymbol(String prefix) {
        
        // Attempt to create an unused Symbol name.
        String generatedSymbolName = prefix + Symbol.generatedSymbolSuffix;
        
        // If that Symbol already exists, increment the counter and try again.
        while(Symbol.symbolDomainOfDiscourse.containsKey(generatedSymbolName)) {
            Symbol.generatedSymbolSuffix++;
            generatedSymbolName = prefix + Symbol.generatedSymbolSuffix;
        }
        
        // Return the new Symbol.
        return Symbol.get(generatedSymbolName);
    }
    
    /**
     * Constructs a Symbol of the given name.
     * 
     * @param name The name of the symbol.
     */
    private Symbol(String name) {
        this.name = name;
    }
    
    /*
     * (non-Javadoc)
     * @see java.lang.Object#clone()
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException("Symbol.clone() is not supported");
    }
    
    /**
     * Compares this Symbol to the parameter object. The result is true if and only if the argument 
     * is another Symbol that represents the same sequence of characters as this object.
     * 
     * @param obj The object to compare this Symbol against.
     * @return true if the given object represents a Symbol whose name is syntactically equivalent 
     *     to this Symbol's name, false otherwise.
     */
    @Override
    public boolean equals(Object obj) {
        if( ! (obj instanceof Symbol)) {
            return false;
        }
        
        Symbol other = (Symbol) obj;
        return (this.name.equals(other.name));
    }
    
    /**
     * Returns a hash code for this Symbol. The hash code for a Symbol object is computed as the 
     * hash of the sequence of characters the Symbol represents; i.e
     * {@code toString().hashCode()}.
     * 
     * @return a hash code value for this object.
     */
    @Override
    public int hashCode() {
        return this.name.hashCode();
    }
    
    /**
     * Returns a String representation of this Symbol, which is simply the name that this object 
     * represents.
     * 
     * @return a String representation of this Symbol.
     */
    @Override
    public String toString() {
        return this.name;
    }
}
